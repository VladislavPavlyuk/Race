Создать приложение гонку.

1. Создать класс Car
a. Создать класс Car
b. Добавить 2 основных поля: name, maxSpeed
c. Создать конструктор Runnable

2. Создать класс RaceCarRunnable
a. Создать класс RaceCarRunnable который расширяет Car
b. Добавить поля passed (пройденная дистанция), distance (длинна трассы), isFinish (флаг завершения гонки)
c. Реализовать конструктор с параметрами класса Car и полем distance
d. Реализовать метод getRandomSpeed, в котором скорость машины будет определяться по интервалу (min: maxSpeed/2, max: maxSpeed)
e. Вывести на экран сообщение по шаблону (“carName => speed: 123; progress: 55/350“, где carName – имя машины, 123 – текущая скорость, 55 – пройденный путь, 350 – длинна трассы)

3. Симуляция движения машины
a. В методе run определить цикл while(!isFinish)
b. В цикле каждую секунду ( sleep(1000) ), выполнять расчет пройденной дистанции (в метрах), зная текущую скорость (из метода getRandomSpeed) и интервал времени в 1с.
c. Добавить проверку. Если машина прошла дистанцию >= длинны трассы, устанавливать флаг isFinish в true.

4. Создать класс Race
a. Создать класс Race c методом main
b. Создать ArrayList< RaceCarRunnable > cars и добавить в него несколько «гоночных машин»
c. Создать ArrayList< Thread > и проинициализировать его объектами потоков с машинами. (new Thread(car))

5. Централизованный старт гонки
a. Создать статический метод static void startRace(List<Thread> cars) в классе Race
b. В методе создать поток на основе анонимного класса ( new Thread(new Runnable() {...} )
c. В методе run определить цикл отсчета до старта.
d. Вывести с интервалом в 500мс сообщения: “3...”, “2...”, “1...”, ”GO!!!”
e. Сразу же после ”GO!!!” создать цикл по списку потоков и выполнить start() каждого потока гоночной машины.
f. Вызвать метод startRace в методе main и посмотреть как гоняют машинки

6. Подсчет результатов
a. Для подсчета результатов гонки необходимо синхронизировать момент пересечения финишной черты всеми гонщиками
b. Для этого нужно использовать CountDownLatch
c. Создать в классе Race в методе main счетчик new CountDownLatch(n), в конструкторе указав кол-во участников гонки.
d. Модернизировать класс RaceCarRunnable. Добавить в него поле CountDownLatch и добавить его в качестве параметра канструктора.
e. В методе run класса RaceCarRunnable вызвать метод latch.countDown(); на момент финиша машины.
f. Добавить «точку ожидания» ( latch.await(); ) после вызова метода startRace().
g. Вывести всех финишировавших машин на экран по шаблону “carName FINISHED !”

7. Определение победителя
a. Добавить статическое поле время старта гонки. В классе Race определить публичное статическое поле startRaceTime типа AtomicLong
b. Проинициализировать его значением текущего системного времени, на момент старта всех потоков.
c. Добавить поле long finishTime; в класс RaceCarRunnable.
d. Добавить геттер на это поле.
e. На момент пересечения машиной финиша расчитать время гонки. Текущее системное время минус время начала гонки (finishTime)
Результат занести в поле finishTime
f. Доработать вывод результатов гонки, добавить время заезда каждой машины к выводу результата.
g. На основе известных результатов заезда определить победителя (у кого finishTime самый маленький).
h. Вывести победителя на экран.

9. Форматирование времени *
a. Создать статический метод static String convertToTime(long time), который конвертирует время гонки из мс в форматированный интервал времени. Использовать SimpleDateFormat.
